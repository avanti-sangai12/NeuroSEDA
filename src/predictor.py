# ============================================================================\n# Next-Element Predictor\n# ============================================================================\n# Predicts the next element to interact with based on:\n# 1. Action history and patterns\n# 2. Element relationships and proximity\n# 3. Common workflow sequences\n# ============================================================================\n\nfrom typing import List, Dict, Tuple, Optional\nfrom collections import defaultdict, Counter\nfrom datetime import datetime, timedelta\nimport json\n\nfrom hybrid_selector import HybridElementSelector, config, normalize_text\n\n\nclass ActionHistory:\n    \"\"\"Track user action sequences\"\"\"\n    def __init__(self, max_history=50):\n        self.actions = []  # List of {time, element_text, element_idx, bbox, action_type}\n        self.max_history = max_history\n        self.action_sequences = defaultdict(list)  # Maps element -> next elements\n    \n    def add_action(self, element_text: str, element_idx: int, bbox: List, action_type: str = 'click'):\n        \"\"\"Record a user action\"\"\"\n        action = {\n            'time': datetime.now().isoformat(),\n            'text': element_text,\n            'idx': element_idx,\n            'bbox': bbox,\n            'type': action_type\n        }\n        self.actions.append(action)\n        \n        # Keep history bounded\n        if len(self.actions) > self.max_history:\n            self.actions.pop(0)\n        \n        # Update sequences\n        if len(self.actions) >= 2:\n            prev_action = self.actions[-2]\n            self._update_sequences(prev_action['text'], element_text)\n    \n    def _update_sequences(self, prev_text: str, curr_text: str):\n        \"\"\"Learn action sequences\"\"\"\n        norm_prev = normalize_text(prev_text)\n        self.action_sequences[norm_prev].append(normalize_text(curr_text))\n    \n    def get_likely_next_actions(self, current_element_text: str, top_k: int = 3) -> List[Tuple[str, float]]:\n        \"\"\"Get likely next actions based on history\"\"\"\n        norm_text = normalize_text(current_element_text)\n        \n        if norm_text not in self.action_sequences:\n            return []\n        \n        # Count frequency of next actions\n        next_actions = self.action_sequences[norm_text]\n        counter = Counter(next_actions)\n        total = len(next_actions)\n        \n        # Return top K with confidence scores\n        results = []\n        for action, count in counter.most_common(top_k):\n            confidence = (count / total) * 100\n            results.append((action, confidence))\n        \n        return results\n    \n    def to_dict(self) -> Dict:\n        \"\"\"Serialize for storage\"\"\"\n        return {\n            'actions': self.actions[-10:],  # Keep last 10\n            'sequences': {k: list(Counter(v).most_common(5)) for k, v in self.action_sequences.items()}\n        }\n\n\nclass ElementRelationshipAnalyzer:\n    \"\"\"Analyze relationships between elements on page\"\"\"\n    \n    @staticmethod\n    def compute_spatial_proximity(bbox1: List, bbox2: List) -> float:\n        \"\"\"Compute distance between two bounding boxes\"\"\"\n        x1_1, y1_1, x2_1, y2_1 = bbox1\n        x1_2, y1_2, x2_2, y2_2 = bbox2\n        \n        # Center points\n        cx1, cy1 = (x1_1 + x2_1) / 2, (y1_1 + y2_1) / 2\n        cx2, cy2 = (x1_2 + x2_2) / 2, (y1_2 + y2_2) / 2\n        \n        # Euclidean distance\n        distance = ((cx1 - cx2) ** 2 + (cy1 - cy2) ** 2) ** 0.5\n        return distance\n    \n    @staticmethod\n    def is_nearby(bbox1: List, bbox2: List, threshold: float = 0.15) -> bool:\n        \"\"\"Check if two elements are spatially close\"\"\"\n        distance = ElementRelationshipAnalyzer.compute_spatial_proximity(bbox1, bbox2)\n        return distance < threshold\n    \n    @staticmethod\n    def find_related_elements(\n        reference_element: Dict,\n        all_elements: List[Dict],\n        max_related: int = 3\n    ) -> List[Dict]:\n        \"\"\"Find elements spatially or semantically related to reference element\"\"\"\n        ref_bbox = reference_element.get('bbox', [0, 0, 1, 1])\n        \n        related = []\n        for elem in all_elements:\n            if elem.get('idx') == reference_element.get('idx'):\n                continue  # Skip self\n            \n            # Compute proximity\n            distance = ElementRelationshipAnalyzer.compute_spatial_proximity(\n                ref_bbox, elem.get('bbox', [0, 0, 1, 1])\n            )\n            \n            # Elements within reasonable distance\n            if distance < 0.3:  # Adjust threshold as needed\n                related.append((elem, distance))\n        \n        # Sort by distance and return top K\n        related.sort(key=lambda x: x[1])\n        return [elem for elem, _ in related[:max_related]]\n\n\nclass NextElementPredictor:\n    \"\"\"Predict next element and action to take\"\"\"\n    \n    def __init__(self):\n        self.selector = HybridElementSelector(config)\n        self.history = ActionHistory()\n        self.analyzer = ElementRelationshipAnalyzer()\n    \n    def predict_next_element(\n        self,\n        current_element: Dict,\n        all_elements: List[Dict],\n        context_instruction: Optional[str] = None,\n        use_history: bool = True,\n        use_proximity: bool = True\n    ) -> List[Dict]:\n        \"\"\"\n        Predict next element(s) to interact with.\n        \n        Returns list of predictions sorted by confidence:\n        [\n            {\n                'element': dict,\n                'action': str (click/input/scroll),\n                'confidence': float (0-100),\n                'reason': str,\n                'rank': int\n            },\n            ...\n        ]\n        \"\"\"\n        predictions = []\n        scores = defaultdict(lambda: {'confidence': 0, 'reasons': []})\n        \n        # 1. History-based prediction\n        if use_history and current_element.get('text'):\n            history_predictions = self.history.get_likely_next_actions(\n                current_element['text'], top_k=3\n            )\n            \n            for next_text, confidence in history_predictions:\n                # Find matching element\n                for elem in all_elements:\n                    if normalize_text(elem.get('text', '')) == next_text:\n                        elem_id = id(elem)\n                        scores[elem_id]['confidence'] = max(\n                            scores[elem_id]['confidence'],\n                            confidence * 0.8  # Slightly discount history predictions\n                        )\n                        scores[elem_id]['reasons'].append(\n                            f\"History-based (confidence: {confidence:.0f}%)\"\n                        )\n                        scores[elem_id]['element'] = elem\n                        break\n        \n        # 2. Proximity-based prediction\n        if use_proximity:\n            nearby_elements = self.analyzer.find_related_elements(\n                current_element, all_elements, max_related=5\n            )\n            \n            # Nearby elements get base confidence\n            for i, elem in enumerate(nearby_elements):\n                # Closer = higher confidence\n                proximity_score = (1 - (i / len(nearby_elements))) * 60\n                \n                elem_id = id(elem)\n                scores[elem_id]['confidence'] = max(\n                    scores[elem_id]['confidence'],\n                    proximity_score\n                )\n                scores[elem_id]['reasons'].append(\n                    f\"Spatially nearby (rank: {i+1})\"\n                )\n                scores[elem_id]['element'] = elem\n        \n        # 3. Context-based prediction (if instruction provided)\n        if context_instruction:\n            matching_result = self.selector.select(\n                context_instruction, all_elements, verbose=False\n            )\n            \n            if matching_result['element_idx'] is not None:\n                elem = all_elements[matching_result['element_idx']]\n                elem_id = id(elem)\n                \n                confidence = matching_result['confidence']\n                scores[elem_id]['confidence'] = max(\n                    scores[elem_id]['confidence'],\n                    confidence * 0.7  # Discount context predictions\n                )\n                scores[elem_id]['reasons'].append(\n                    f\"Matches context (confidence: {confidence:.0f}%)\"\n                )\n                scores[elem_id]['element'] = elem\n        \n        # 4. Build final predictions\n        for elem_id, score_data in scores.items():\n            elem = score_data['element']\n            \n            predictions.append({\n                'element': elem,\n                'element_idx': elem.get('idx'),\n                'text': elem.get('text', ''),\n                'bbox': elem.get('bbox', [0, 0, 1, 1]),\n                'action': self._infer_action(elem),\n                'confidence': score_data['confidence'],\n                'reasons': score_data['reasons'],\n                'reason': ' | '.join(score_data['reasons'])\n            })\n        \n        # Sort by confidence\n        predictions.sort(key=lambda x: x['confidence'], reverse=True)\n        \n        # Add ranks\n        for i, pred in enumerate(predictions, 1):\n            pred['rank'] = i\n        \n        return predictions[:5]  # Return top 5\n    \n    def _infer_action(self, element: Dict) -> str:\n        \"\"\"Infer appropriate action for element\"\"\"\n        tag = element.get('tag', '').lower()\n        elem_type = element.get('type', '').lower()\n        text = element.get('text', '').lower()\n        \n        # Input fields\n        if tag in ['input', 'textarea'] or elem_type in ['text', 'password', 'email']:\n            return 'input'\n        \n        # Button/link\n        if tag in ['button', 'a'] or 'button' in text:\n            return 'click'\n        \n        # Dropdown\n        if tag == 'select' or 'select' in text or 'dropdown' in text:\n            return 'select'\n        \n        # Checkbox/radio\n        if elem_type in ['checkbox', 'radio']:\n            return 'toggle'\n        \n        # Default\n        return 'click'\n    \n    def record_action(self, element: Dict, action_type: str = 'click'):\n        \"\"\"Record user action for learning\"\"\"\n        self.history.add_action(\n            element.get('text', 'Unknown'),\n            element.get('idx', -1),\n            element.get('bbox', [0, 0, 1, 1]),\n            action_type\n        )\n    \n    def get_history_summary(self) -> Dict:\n        \"\"\"Get action history summary\"\"\"\n        return self.history.to_dict()\n\n\nclass PredictionSession:\n    \"\"\"Manage prediction sessions across page interactions\"\"\"\n    \n    def __init__(self):\n        self.predictor = NextElementPredictor()\n        self.current_page_url = None\n        self.current_elements = []\n    \n    def update_page(self, url: str, elements: List[Dict]):\n        \"\"\"Update current page context\"\"\"\n        self.current_page_url = url\n        self.current_elements = elements\n    \n    def predict(\n        self,\n        current_element: Dict,\n        instruction: Optional[str] = None,\n        top_k: int = 3\n    ) -> List[Dict]:\n        \"\"\"Get predictions for next action\"\"\"\n        if not self.current_elements:\n            return []\n        \n        predictions = self.predictor.predict_next_element(\n            current_element,\n            self.current_elements,\n            context_instruction=instruction,\n            use_history=True,\n            use_proximity=True\n        )\n        \n        return predictions[:top_k]\n    \n    def record_action(self, element: Dict, action_type: str = 'click'):\n        \"\"\"Record action for learning\"\"\"\n        self.predictor.record_action(element, action_type)\n\n\ndef normalize_text(text: str) -> str:\n    \"\"\"Normalize text for comparison\"\"\"\n    text = text.lower().strip()\n    import re\n    text = re.sub(r'[^\\w\\s]', '', text)\n    text = re.sub(r'\\s+', ' ', text)\n    return text\n"